using "io/file"

type Layer {
	var inputSize:i32
	var outputSize:i32
	var weights:f32[]
	var biases:f32[]
	var weightsMomentum:f32[]
	var biasesMomentum:f32[]

	this() {}

	this(inputSize:i32, outputSize:i32) {
		var n = inputSize * outputSize
		var scale = Math.sqrt(2.0 / inputSize)
		this.inputSize = inputSize
		this.outputSize = outputSize
		this.weights = new f32[n]
		this.biases = new f32[outputSize]
		this.weightsMomentum = new f32[n]
		this.biasesMomentum = new f32[outputSize]

		for i in 0..n {
			this.weights[i] = (Random.next() - 0.5) * 2 * scale
		}
	}
}

type Network {
	var hidden : Layer
	var output : Layer

	this(inputSize:i32, hiddenSize:i32, outputSize:i32) {
		hidden = new Layer(inputSize, hiddenSize)
		output = new Layer(hiddenSize, outputSize)
	}
}

type InputData {
	var images : byte[]
	var labels : byte[]
	var total: i32	

	function shuffle(size:i32) {
		var temp:u8
		for i in 0..total {
			var j = Random.next() % (i + 1) as i32
			for k in 0..size {
				temp = images[i*size+k]
				images[i*size+k] = images[j*size+k]
				images[j*size+k] = temp
			}
			temp = labels[i]
			labels[i] = labels[j]
			labels[j] = temp
		}
	}

	function readImages(file:chars, size:i32)  {
		var f = new FileReader(file,FileReaderMode.READ)
		f.readI32()
		var count = f.readI32().reverse()
		f.readI32()
		f.readI32()
		images = new byte[count * size * size]
		f.read(images, count * size * size)
		f.close()
	}

	function readLabels(file:chars) {
		var f = new FileReader(file,FileReaderMode.READ)
		f.readI32()
		total = f.readI32().reverse()
		labels = new byte[total]
		f.read(labels, total)
		f.close()
	}
}

var hiddenOutput = new f32[256]
var finalOutput = new f32[10]
var hiddenGrad = new f32[256]
var outputGrad = new f32[10]

function forward(layer:Layer, input:f32[], output:f32[]) {
	for i in 0..layer.outputSize {
		output[i] = layer.biases[i]
	}
	for i in 0..layer.inputSize {
		for j in 0..layer.outputSize {
			output[j] += input[i] * layer.weights[i*layer.outputSize+j]
		}
	}
	for i in 0..layer.outputSize {
		if output[i] < 0 => output[i] = 0
	}
}

function softmax(x:f32[], n:i32) {
	var max = x[0]
	for i in 1..n {
		if x[i] > max {
			max = x[i]
		}
	}
	var sum = 0.0
	for i in 0..n {
		x[i] = Math.exp(x[i] - max)
		sum += x[i]
	}
	for i in 0..n {
		x[i] /= sum
	}
}

function backward(layer:Layer, input:f32[], outputGrad:f32[],  inputGrad:f32[], rate:f32) {
	if inputGrad!=null {
		for i in 0..layer.inputSize {
			inputGrad[i] = 0.0
			for j in 0..layer.outputSize {
				inputGrad[i] += outputGrad[j] * layer.weights[i*layer.outputSize+j]
			}
		}
	}
	for i in 0..layer.inputSize {
		for j in 0..layer.outputSize {
			var grad = outputGrad[j] * input[i]
			var index = i*layer.outputSize+j;
			layer.weightsMomentum[index] = 0.9f * layer.weightsMomentum[index] - rate * grad
			layer.weights[index] += layer.weightsMomentum[index]
			if inputGrad!=null {
				inputGrad[i] += outputGrad[j] * layer.weights[index]
			}
		}
	}
	for i in 0..layer.outputSize {
		layer.biasesMomentum[i] = 0.9f * layer.biasesMomentum[i] - rate * outputGrad[i]
		layer.biases[i] += layer.biasesMomentum[i]
	}
}

function train(net:Network, input:f32[], label:byte, rate:f32): f32 {
	forward(net.hidden, input, hiddenOutput)
	forward(net.output, hiddenOutput, finalOutput)
	softmax(finalOutput, 10)

	for i in 0..10 {
		outputGrad[i] = finalOutput[i]- (i == label ? 1.0 : 0.0)
	}
	backward(net.output, hiddenOutput, outputGrad, hiddenGrad, rate)

	for i in 0..256 {
		if hiddenOutput[i] < 0 => hiddenGrad[i] = 0
	}
	backward(net.hidden, input, hiddenGrad, null as f32[], rate)

	return finalOutput[label]
}

function predict(net:Network, input:f32[]): i32 {
	forward(net.hidden, input, hiddenOutput)
	forward(net.output, hiddenOutput, finalOutput)
	softmax(finalOutput, 10)

	var maxIndex = 0
	for i in 0..10 {
		if finalOutput[i] > finalOutput[maxIndex] => maxIndex = i
	}
	return maxIndex
}

main {
	var net = new Network(784,256,10)
	var data = new InputData()	
	data.readImages("./train-images.idx3-ubyte", 28)
	data.readLabels("./train-labels.idx1-ubyte")
	data.shuffle(784)
	var trainSize = data.total * 0.8f
	var testSize = data.total - trainSize

	var img = new f32[784]
	
	for epoch in 0..20 {
		var totalLoss = 0.0
		for i in 0..trainSize {
			for k in 0..784 {
				img[k] = data.images[(i*784)+k] as f32 / 255.0
			}
			var trainValue = train(net, img, data.labels[i], 0.0005f)
			totalLoss += -Math.log(trainValue + 1e-10f)
		}
		var correct = 0
		for i in trainSize..60_000 {
			for k in 0..784 {
				img[k] = data.images[(i*784)+k] as f32 / 255.0
			}
			if predict(net, img) == data.labels[i] {
				correct++
			}
		}
		print("Epoch: %d, Loss: %f, Correct: %d \n", epoch, totalLoss / trainSize, correct as f32 / (testSize * 100) as f32)
	}
}

